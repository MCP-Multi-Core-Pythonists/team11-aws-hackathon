# 002-디바이스플로우인증구현

## 1. Device Flow 개요

### 1.1 OAuth 2.0 Device Authorization Grant
VS Code Extension과 같은 입력이 제한된 디바이스에서 사용하는 OAuth 2.0 인증 방식입니다.

**플로우 특징:**
- 브라우저가 없는 환경에서 인증 가능
- 사용자 친화적인 코드 기반 인증
- 보안성과 사용성의 균형

### 1.2 구현된 플로우
```
1. Extension → Backend: Device Code 요청
2. Backend → Extension: Device Code + User Code 응답  
3. Extension → Browser: 인증 URL 자동 열기
4. User → Web Console: User Code 입력 및 인증
5. Extension → Backend: 토큰 폴링 (5초 간격)
6. Backend → Extension: Access Token + Refresh Token 발급
```

## 2. Backend 구현

### 2.1 Device Code 생성 엔드포인트
```typescript
// POST /api/v1/auth/device
async requestDeviceCode(req: Request, res: Response, next: NextFunction) {
  try {
    const { client_id } = req.body;
    
    // Device Code와 User Code 생성
    const deviceCode = crypto.randomBytes(32).toString('hex');
    const userCode = Math.random().toString(36).substring(2, 8).toUpperCase();
    
    // Redis에 저장 (10분 만료)
    await redis.setex(`device:${deviceCode}`, 600, JSON.stringify({
      user_code: userCode,
      client_id,
      created_at: Date.now(),
      status: 'pending'
    }));
    
    await redis.setex(`user_code:${userCode}`, 600, deviceCode);
    
    res.json({
      device_code: deviceCode,
      user_code: userCode,
      verification_uri: 'http://localhost:3000/device',
      expires_in: 600,
      interval: 5
    });
  } catch (error) {
    next(error);
  }
}
```

### 2.2 토큰 폴링 엔드포인트
```typescript
// POST /api/v1/auth/token
async handleTokenRequest(req: Request, res: Response, next: NextFunction) {
  try {
    const { grant_type, device_code } = req.body;
    
    if (grant_type !== 'device_code') {
      return res.status(400).json({ error: 'unsupported_grant_type' });
    }
    
    const deviceData = await redis.get(`device:${device_code}`);
    if (!deviceData) {
      return res.status(400).json({ error: 'expired_token' });
    }
    
    const device = JSON.parse(deviceData);
    
    if (device.status === 'pending') {
      return res.status(400).json({ error: 'authorization_pending' });
    }
    
    if (device.status === 'approved' && device.user_id) {
      const user = await User.findByPk(device.user_id);
      const tokens = await this.tokenService.generateTokens(
        user.id, user.email, user.name
      );
      
      // Device code 정리
      await redis.del(`device:${device_code}`);
      await redis.del(`user_code:${device.user_code}`);
      
      res.json({
        access_token: tokens.accessToken,
        refresh_token: tokens.refreshToken,
        token_type: 'Bearer',
        expires_in: tokens.expiresIn
      });
    } else {
      res.status(400).json({ error: 'access_denied' });
    }
  } catch (error) {
    next(error);
  }
}
```

### 2.3 Device 승인 엔드포인트
```typescript
// POST /api/v1/auth/device/approve
async approveDevice(req: Request, res: Response, next: NextFunction) {
  try {
    const { user_code } = req.body;
    const userId = req.user!.id;
    
    const deviceCode = await redis.get(`user_code:${user_code}`);
    if (!deviceCode) {
      return res.status(400).json({ error: 'Invalid user code' });
    }
    
    const deviceData = await redis.get(`device:${deviceCode}`);
    if (!deviceData) {
      return res.status(400).json({ error: 'Device code expired' });
    }
    
    const device = JSON.parse(deviceData);
    device.status = 'approved';
    device.user_id = userId;
    
    await redis.setex(`device:${deviceCode}`, 600, JSON.stringify(device));
    
    res.json({ success: true, message: 'Device approved successfully' });
  } catch (error) {
    next(error);
  }
}
```

## 3. Extension 구현

### 3.1 AuthProvider 클래스
```typescript
export class AuthProvider {
  private context: vscode.ExtensionContext;
  private readonly API_BASE_URL = 'http://localhost:3001/api/v1';
  private tokens: AuthTokens | null = null;

  async login(): Promise<boolean> {
    try {
      // 1. Device Code 요청
      const deviceCode = await this.requestDeviceCode();
      
      // 2. 사용자에게 인증 URL 표시
      const authUrl = `${deviceCode.verification_uri}?user_code=${deviceCode.user_code}`;
      
      const result = await vscode.window.showInformationMessage(
        `브라우저에서 인증을 완료해주세요.\n코드: ${deviceCode.user_code}`,
        '브라우저 열기',
        '취소'
      );

      if (result === '브라우저 열기') {
        await vscode.env.openExternal(vscode.Uri.parse(authUrl));
      } else {
        return false;
      }

      // 3. 토큰 폴링
      const tokens = await this.pollForTokens(deviceCode.device_code, deviceCode.interval);
      
      if (tokens) {
        await this.saveTokens(tokens);
        vscode.window.showInformationMessage('TeamSync 로그인 성공!');
        return true;
      }

      return false;
    } catch (error) {
      Logger.error('로그인 실패:', error);
      vscode.window.showErrorMessage(`로그인 실패: ${error.message}`);
      return false;
    }
  }
}
```

### 3.2 Device Code 요청
```typescript
private async requestDeviceCode(): Promise<DeviceCodeResponse> {
  const response = await fetch(`${this.API_BASE_URL}/auth/device`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      client_id: 'vscode-extension'
    })
  });

  if (!response.ok) {
    throw new Error('Device code 요청 실패');
  }

  return response.json() as Promise<DeviceCodeResponse>;
}
```

### 3.3 토큰 폴링
```typescript
private async pollForTokens(deviceCode: string, interval: number): Promise<AuthTokens | null> {
  const maxAttempts = 60; // 5분 (5초 * 60)
  let attempts = 0;

  return new Promise((resolve) => {
    const poll = async () => {
      attempts++;
      
      if (attempts > maxAttempts) {
        resolve(null);
        return;
      }

      try {
        const response = await fetch(`${this.API_BASE_URL}/auth/token`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            grant_type: 'device_code',
            device_code: deviceCode
          })
        });

        if (response.ok) {
          const tokens = await response.json() as any;
          resolve({
            accessToken: tokens.access_token,
            refreshToken: tokens.refresh_token,
            expiresAt: Date.now() + (tokens.expires_in * 1000)
          });
          return;
        }

        // 아직 인증되지 않음, 계속 폴링
        setTimeout(poll, interval * 1000);
      } catch (error) {
        Logger.error('토큰 폴링 오류:', error);
        setTimeout(poll, interval * 1000);
      }
    };

    poll();
  });
}
```

## 4. Frontend 구현

### 4.1 Device 인증 페이지
```typescript
const DevicePage: React.FC = () => {
  const [userCode, setUserCode] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const [message, setMessage] = useState('');

  // URL에서 user_code 파라미터 가져오기
  React.useEffect(() => {
    const urlParams = new URLSearchParams(window.location.search);
    const code = urlParams.get('user_code');
    if (code) {
      setUserCode(code);
    }
  }, []);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!userCode.trim()) {
      setMessage('코드를 입력해주세요.');
      return;
    }

    setIsLoading(true);
    setMessage('');

    try {
      await authService.approveDevice(userCode);
      setMessage('✅ 디바이스 인증이 완료되었습니다! VS Code로 돌아가세요.');
    } catch (error) {
      setMessage('❌ 인증에 실패했습니다. 다시 시도해주세요.');
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div className="min-h-screen bg-gray-50 flex items-center justify-center">
      <div className="max-w-md w-full space-y-8">
        <div>
          <h2 className="text-center text-3xl font-extrabold text-gray-900">
            TeamSync Pro
          </h2>
          <p className="text-center text-sm text-gray-600">
            VS Code Extension 디바이스 인증
          </p>
        </div>
        
        <form className="space-y-6" onSubmit={handleSubmit}>
          <div>
            <label className="block text-sm font-medium text-gray-700">
              인증 코드
            </label>
            <input
              type="text"
              value={userCode}
              onChange={(e) => setUserCode(e.target.value.toUpperCase())}
              placeholder="예: ABC1-DEF2"
              className="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md"
              required
            />
          </div>

          <button
            type="submit"
            disabled={isLoading}
            className="w-full py-2 px-4 border border-transparent rounded-md text-white bg-indigo-600 hover:bg-indigo-700 disabled:opacity-50"
          >
            {isLoading ? '인증 중...' : '디바이스 인증'}
          </button>

          {message && (
            <div className={`text-center text-sm ${message.includes('✅') ? 'text-green-600' : 'text-red-600'}`}>
              {message}
            </div>
          )}
        </form>
      </div>
    </div>
  );
};
```

### 4.2 인증 서비스
```typescript
class AuthService {
  async approveDevice(userCode: string): Promise<void> {
    const response = await api.post('/auth/device/approve', { 
      user_code: userCode 
    });
    
    if (!response.data.success) {
      throw new Error('Device approval failed');
    }
  }

  async getCurrentUser(): Promise<User> {
    const response = await api.get('/auth/me');
    return response.data;
  }
}

export const authService = new AuthService();
```

## 5. 보안 고려사항

### 5.1 Device Code 보안
- **만료 시간**: 10분으로 제한하여 보안 위험 최소화
- **복잡도**: 32바이트 랜덤 생성으로 추측 불가능
- **일회성**: 사용 후 즉시 삭제

### 5.2 User Code 보안
- **길이**: 6자리로 사용자 입력 편의성 고려
- **형식**: 대문자 + 숫자 조합으로 가독성 향상
- **충돌 방지**: Redis 키 중복 검사

### 5.3 토큰 보안
- **Access Token**: 1시간 만료, JWT 서명 검증
- **Refresh Token**: 30일 만료, 로테이션 적용
- **저장**: VS Code Secret Storage 사용

## 6. 에러 처리

### 6.1 Backend 에러 응답
```typescript
// 표준 에러 응답 형식
interface ErrorResponse {
  error: string;
  error_description?: string;
  timestamp: string;
}

// 주요 에러 코드
const ERROR_CODES = {
  EXPIRED_TOKEN: 'expired_token',
  AUTHORIZATION_PENDING: 'authorization_pending',
  ACCESS_DENIED: 'access_denied',
  INVALID_GRANT: 'invalid_grant',
  UNSUPPORTED_GRANT_TYPE: 'unsupported_grant_type'
};
```

### 6.2 Extension 에러 처리
```typescript
// 네트워크 에러 처리
async function handleApiCall<T>(apiCall: () => Promise<T>): Promise<T> {
  try {
    return await apiCall();
  } catch (error) {
    if (error instanceof TypeError && error.message.includes('fetch')) {
      throw new Error('서버에 연결할 수 없습니다. 네트워크 연결을 확인해주세요.');
    }
    
    if (error.status === 400) {
      const errorData = await error.json();
      switch (errorData.error) {
        case 'authorization_pending':
          // 계속 폴링
          break;
        case 'expired_token':
          throw new Error('인증 시간이 만료되었습니다. 다시 시도해주세요.');
        case 'access_denied':
          throw new Error('인증이 거부되었습니다.');
        default:
          throw new Error('인증 중 오류가 발생했습니다.');
      }
    }
    
    throw error;
  }
}
```

## 7. 테스트

### 7.1 Backend 테스트
```typescript
describe('Device Flow Authentication', () => {
  test('should generate device code', async () => {
    const response = await request(app)
      .post('/api/v1/auth/device')
      .send({ client_id: 'vscode-extension' })
      .expect(200);

    expect(response.body).toHaveProperty('device_code');
    expect(response.body).toHaveProperty('user_code');
    expect(response.body.expires_in).toBe(600);
  });

  test('should return authorization_pending for unapproved device', async () => {
    const deviceResponse = await request(app)
      .post('/api/v1/auth/device')
      .send({ client_id: 'vscode-extension' });

    const tokenResponse = await request(app)
      .post('/api/v1/auth/token')
      .send({
        grant_type: 'device_code',
        device_code: deviceResponse.body.device_code
      })
      .expect(400);

    expect(tokenResponse.body.error).toBe('authorization_pending');
  });
});
```

### 7.2 Extension 테스트
```typescript
describe('AuthProvider', () => {
  test('should handle device code flow', async () => {
    const mockDeviceCode = {
      device_code: 'test-device-code',
      user_code: 'TEST123',
      verification_uri: 'http://localhost:3000/device',
      expires_in: 600,
      interval: 5
    };

    // Mock fetch responses
    global.fetch = jest.fn()
      .mockResolvedValueOnce({
        ok: true,
        json: () => Promise.resolve(mockDeviceCode)
      })
      .mockResolvedValueOnce({
        ok: true,
        json: () => Promise.resolve({
          access_token: 'test-access-token',
          refresh_token: 'test-refresh-token',
          expires_in: 3600
        })
      });

    const authProvider = new AuthProvider(mockContext);
    const result = await authProvider.login();

    expect(result).toBe(true);
    expect(fetch).toHaveBeenCalledTimes(2);
  });
});
```

## 8. 모니터링 및 로깅

### 8.1 로깅 포인트
```typescript
// Device Code 생성 로그
Logger.info('Device code generated', {
  userCode,
  clientId: client_id,
  expiresIn: 600
});

// 토큰 폴링 로그
Logger.info('Token polling attempt', {
  deviceCode: deviceCode.substring(0, 8) + '...',
  attempt: attempts,
  status: device.status
});

// 인증 완료 로그
Logger.info('Device authentication completed', {
  userId: user.id,
  userEmail: user.email,
  deviceCode: deviceCode.substring(0, 8) + '...'
});
```

### 8.2 메트릭 수집
- **Device Code 생성 수**: 시간당 생성된 Device Code 수
- **인증 성공률**: 생성된 Device Code 대비 성공한 인증 비율
- **평균 인증 시간**: Device Code 생성부터 토큰 발급까지 소요 시간
- **만료율**: 시간 초과로 만료된 Device Code 비율

## 9. TODO 및 개선사항

### 9.1 단기 개선사항
- [ ] User Code 형식 개선 (하이픈 추가: ABC1-DEF2)
- [ ] 인증 진행 상태 실시간 표시
- [ ] 에러 메시지 다국어 지원
- [ ] 토큰 갱신 자동화

### 9.2 중기 개선사항
- [ ] QR 코드 기반 인증 추가
- [ ] 다중 디바이스 관리
- [ ] 인증 히스토리 추적
- [ ] 보안 알림 시스템

### 9.3 장기 개선사항
- [ ] PKCE (Proof Key for Code Exchange) 적용
- [ ] WebAuthn 지원
- [ ] SSO 연동
- [ ] 엔터프라이즈 정책 적용
