# 006-인증보안구현.md

## 인증 시스템 아키텍처

### 인증 플로우 개요
```
1. OAuth 2.0 Device Flow (VS Code Extension)
2. OAuth 2.0 Authorization Code Flow (Web Console)
3. JWT Access Token + Refresh Token
4. Role-based Access Control (RBAC)
```

### OAuth 2.0 Provider 설정

#### Google OAuth 설정
```javascript
// src/config/oauth.ts
export const googleOAuthConfig = {
  clientId: process.env.GOOGLE_CLIENT_ID!,
  clientSecret: process.env.GOOGLE_CLIENT_SECRET!,
  redirectUri: process.env.GOOGLE_REDIRECT_URI!,
  scopes: ['openid', 'email', 'profile'],
  authUrl: 'https://accounts.google.com/o/oauth2/v2/auth',
  tokenUrl: 'https://oauth2.googleapis.com/token',
  userInfoUrl: 'https://www.googleapis.com/oauth2/v2/userinfo'
};
```

#### GitHub OAuth 설정
```javascript
export const githubOAuthConfig = {
  clientId: process.env.GITHUB_CLIENT_ID!,
  clientSecret: process.env.GITHUB_CLIENT_SECRET!,
  redirectUri: process.env.GITHUB_REDIRECT_URI!,
  scopes: ['user:email'],
  authUrl: 'https://github.com/login/oauth/authorize',
  tokenUrl: 'https://github.com/login/oauth/access_token',
  userInfoUrl: 'https://api.github.com/user'
};
```

### JWT 토큰 관리

#### 토큰 생성 서비스
```typescript
// src/services/tokenService.ts
import jwt from 'jsonwebtoken';
import crypto from 'crypto';
import { RefreshToken } from '../models/RefreshToken';

interface TokenPayload {
  userId: string;
  email: string;
  name: string;
  iat: number;
  exp: number;
}

export class TokenService {
  private readonly ACCESS_TOKEN_SECRET = process.env.JWT_ACCESS_SECRET!;
  private readonly REFRESH_TOKEN_SECRET = process.env.JWT_REFRESH_SECRET!;
  private readonly ACCESS_TOKEN_EXPIRY = '15m';
  private readonly REFRESH_TOKEN_EXPIRY = '7d';

  async generateTokens(userId: string, email: string, name: string) {
    // Access Token 생성
    const accessToken = jwt.sign(
      { userId, email, name },
      this.ACCESS_TOKEN_SECRET,
      { expiresIn: this.ACCESS_TOKEN_EXPIRY }
    );

    // Refresh Token 생성
    const refreshTokenValue = crypto.randomBytes(32).toString('hex');
    const refreshTokenHash = crypto
      .createHash('sha256')
      .update(refreshTokenValue)
      .digest('hex');

    // Refresh Token DB 저장
    const expiresAt = new Date();
    expiresAt.setDate(expiresAt.getDate() + 7); // 7일 후 만료

    await RefreshToken.create({
      userId,
      tokenHash: refreshTokenHash,
      expiresAt
    });

    return {
      accessToken,
      refreshToken: refreshTokenValue,
      expiresIn: 15 * 60 // 15분 (초 단위)
    };
  }

  async refreshTokens(refreshTokenValue: string) {
    const refreshTokenHash = crypto
      .createHash('sha256')
      .update(refreshTokenValue)
      .digest('hex');

    const refreshToken = await RefreshToken.findOne({
      where: {
        tokenHash: refreshTokenHash,
        revokedAt: null
      },
      include: ['user']
    });

    if (!refreshToken || refreshToken.expiresAt < new Date()) {
      throw new Error('Invalid or expired refresh token');
    }

    // 기존 토큰 무효화
    await refreshToken.update({ revokedAt: new Date() });

    // 새 토큰 생성
    return this.generateTokens(
      refreshToken.userId,
      refreshToken.user.email,
      refreshToken.user.name
    );
  }

  verifyAccessToken(token: string): TokenPayload {
    try {
      return jwt.verify(token, this.ACCESS_TOKEN_SECRET) as TokenPayload;
    } catch (error) {
      throw new Error('Invalid access token');
    }
  }

  async revokeRefreshToken(refreshTokenValue: string) {
    const refreshTokenHash = crypto
      .createHash('sha256')
      .update(refreshTokenValue)
      .digest('hex');

    await RefreshToken.update(
      { revokedAt: new Date() },
      { where: { tokenHash: refreshTokenHash } }
    );
  }

  async revokeAllUserTokens(userId: string) {
    await RefreshToken.update(
      { revokedAt: new Date() },
      { where: { userId, revokedAt: null } }
    );
  }
}
```

### Device Flow 구현 (VS Code Extension)

#### Device Code 생성
```typescript
// src/controllers/authController.ts
export class AuthController {
  async requestDeviceCode(req: Request, res: Response) {
    try {
      const { client_id } = req.body;

      if (client_id !== 'vscode-extension') {
        return res.status(400).json({ error: 'Invalid client_id' });
      }

      const deviceCode = crypto.randomBytes(32).toString('hex');
      const userCode = this.generateUserCode();
      const expiresIn = 600; // 10분

      // Redis에 저장
      await redis.setex(`device_code:${deviceCode}`, expiresIn, JSON.stringify({
        userCode,
        clientId: client_id,
        createdAt: Date.now()
      }));

      res.json({
        device_code: deviceCode,
        user_code: userCode,
        verification_uri: `${process.env.FRONTEND_URL}/auth/device`,
        expires_in: expiresIn,
        interval: 5
      });
    } catch (error) {
      res.status(500).json({ error: 'Internal server error' });
    }
  }

  async pollForToken(req: Request, res: Response) {
    try {
      const { grant_type, device_code } = req.body;

      if (grant_type !== 'device_code') {
        return res.status(400).json({ error: 'unsupported_grant_type' });
      }

      const deviceData = await redis.get(`device_code:${device_code}`);
      if (!deviceData) {
        return res.status(400).json({ error: 'expired_token' });
      }

      const { userCode } = JSON.parse(deviceData);
      
      // 사용자 승인 확인
      const approvalData = await redis.get(`device_approval:${userCode}`);
      if (!approvalData) {
        return res.status(400).json({ error: 'authorization_pending' });
      }

      const { userId } = JSON.parse(approvalData);
      const user = await User.findByPk(userId);

      if (!user) {
        return res.status(400).json({ error: 'access_denied' });
      }

      // 토큰 생성
      const tokens = await tokenService.generateTokens(
        user.id,
        user.email,
        user.name
      );

      // 임시 데이터 삭제
      await redis.del(`device_code:${device_code}`);
      await redis.del(`device_approval:${userCode}`);

      res.json({
        access_token: tokens.accessToken,
        refresh_token: tokens.refreshToken,
        token_type: 'Bearer',
        expires_in: tokens.expiresIn
      });
    } catch (error) {
      res.status(500).json({ error: 'Internal server error' });
    }
  }

  private generateUserCode(): string {
    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
    let result = '';
    for (let i = 0; i < 8; i++) {
      result += chars.charAt(Math.floor(Math.random() * chars.length));
    }
    return result.match(/.{1,4}/g)?.join('-') || result;
  }
}
```

### 권한 관리 시스템

#### Role-based Access Control
```typescript
// src/middleware/authorization.ts
export enum Permission {
  // 팀 권한
  TEAM_READ = 'team:read',
  TEAM_UPDATE = 'team:update',
  TEAM_DELETE = 'team:delete',
  TEAM_INVITE = 'team:invite',
  
  // 설정 권한
  CONFIG_READ = 'config:read',
  CONFIG_CREATE = 'config:create',
  CONFIG_UPDATE = 'config:update',
  CONFIG_DELETE = 'config:delete',
  
  // 프롬프트 권한
  PROMPT_READ = 'prompt:read',
  PROMPT_CREATE = 'prompt:create',
  PROMPT_UPDATE = 'prompt:update',
  PROMPT_DELETE = 'prompt:delete'
}

export const RolePermissions = {
  owner: [
    Permission.TEAM_READ,
    Permission.TEAM_UPDATE,
    Permission.TEAM_DELETE,
    Permission.TEAM_INVITE,
    Permission.CONFIG_READ,
    Permission.CONFIG_CREATE,
    Permission.CONFIG_UPDATE,
    Permission.CONFIG_DELETE,
    Permission.PROMPT_READ,
    Permission.PROMPT_CREATE,
    Permission.PROMPT_UPDATE,
    Permission.PROMPT_DELETE
  ],
  admin: [
    Permission.TEAM_READ,
    Permission.TEAM_UPDATE,
    Permission.TEAM_INVITE,
    Permission.CONFIG_READ,
    Permission.CONFIG_CREATE,
    Permission.CONFIG_UPDATE,
    Permission.PROMPT_READ,
    Permission.PROMPT_CREATE,
    Permission.PROMPT_UPDATE,
    Permission.PROMPT_DELETE
  ],
  member: [
    Permission.TEAM_READ,
    Permission.CONFIG_READ,
    Permission.PROMPT_READ,
    Permission.PROMPT_CREATE
  ]
};

export const requirePermission = (permission: Permission) => {
  return async (req: Request, res: Response, next: NextFunction) => {
    try {
      const { teamId } = req.params;
      const userId = req.user!.id;

      const teamMember = await TeamMember.findOne({
        where: { teamId, userId }
      });

      if (!teamMember) {
        return res.status(403).json({ error: 'Not a team member' });
      }

      const userPermissions = RolePermissions[teamMember.role as keyof typeof RolePermissions];
      
      if (!userPermissions.includes(permission)) {
        return res.status(403).json({ error: 'Insufficient permissions' });
      }

      req.teamMember = teamMember;
      next();
    } catch (error) {
      next(error);
    }
  };
};
```

### 보안 미들웨어

#### Rate Limiting
```typescript
// src/middleware/rateLimiting.ts
import rateLimit from 'express-rate-limit';
import RedisStore from 'rate-limit-redis';
import { redis } from '../config/redis';

// 일반 API 제한
export const apiLimiter = rateLimit({
  store: new RedisStore({
    sendCommand: (...args: string[]) => redis.call(...args),
  }),
  windowMs: 15 * 60 * 1000, // 15분
  max: 100, // IP당 최대 100 요청
  message: {
    error: 'Too many requests from this IP, please try again later.'
  }
});

// 인증 API 제한 (더 엄격)
export const authLimiter = rateLimit({
  store: new RedisStore({
    sendCommand: (...args: string[]) => redis.call(...args),
  }),
  windowMs: 15 * 60 * 1000, // 15분
  max: 5, // IP당 최대 5 요청
  message: {
    error: 'Too many authentication attempts, please try again later.'
  }
});

// 사용자별 제한
export const userLimiter = rateLimit({
  store: new RedisStore({
    sendCommand: (...args: string[]) => redis.call(...args),
  }),
  windowMs: 60 * 1000, // 1분
  max: 30, // 사용자당 최대 30 요청
  keyGenerator: (req) => req.user?.id || req.ip,
  message: {
    error: 'Too many requests from this user, please try again later.'
  }
});
```

#### 입력 검증
```typescript
// src/middleware/validation.ts
import Joi from 'joi';

export const validateRequest = (schema: {
  body?: Joi.ObjectSchema;
  query?: Joi.ObjectSchema;
  params?: Joi.ObjectSchema;
}) => {
  return (req: Request, res: Response, next: NextFunction) => {
    const errors: string[] = [];

    // Body 검증
    if (schema.body) {
      const { error } = schema.body.validate(req.body);
      if (error) {
        errors.push(`Body: ${error.details[0].message}`);
      }
    }

    // Query 검증
    if (schema.query) {
      const { error } = schema.query.validate(req.query);
      if (error) {
        errors.push(`Query: ${error.details[0].message}`);
      }
    }

    // Params 검증
    if (schema.params) {
      const { error } = schema.params.validate(req.params);
      if (error) {
        errors.push(`Params: ${error.details[0].message}`);
      }
    }

    if (errors.length > 0) {
      return res.status(400).json({
        error: 'Validation failed',
        details: errors
      });
    }

    next();
  };
};

// 스키마 정의 예시
export const teamSchemas = {
  create: {
    body: Joi.object({
      name: Joi.string().min(2).max(100).required(),
      description: Joi.string().max(500).optional()
    })
  },
  update: {
    params: Joi.object({
      id: Joi.string().uuid().required()
    }),
    body: Joi.object({
      name: Joi.string().min(2).max(100).optional(),
      description: Joi.string().max(500).optional()
    })
  }
};
```

### 보안 헤더 설정

#### Helmet 설정
```typescript
// src/middleware/security.ts
import helmet from 'helmet';

export const securityHeaders = helmet({
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      styleSrc: ["'self'", "'unsafe-inline'", "https://fonts.googleapis.com"],
      fontSrc: ["'self'", "https://fonts.gstatic.com"],
      scriptSrc: ["'self'"],
      imgSrc: ["'self'", "data:", "https:"],
      connectSrc: ["'self'", "https://api.github.com", "https://accounts.google.com"],
      frameSrc: ["'none'"],
      objectSrc: ["'none'"],
      upgradeInsecureRequests: []
    }
  },
  hsts: {
    maxAge: 31536000, // 1년
    includeSubDomains: true,
    preload: true
  },
  noSniff: true,
  frameguard: { action: 'deny' },
  xssFilter: true,
  referrerPolicy: { policy: 'strict-origin-when-cross-origin' }
});
```

### 암호화 및 해싱

#### 비밀번호 해싱 (이메일 로그인용)
```typescript
// src/utils/crypto.ts
import bcrypt from 'bcryptjs';
import crypto from 'crypto';

export class CryptoUtils {
  static async hashPassword(password: string): Promise<string> {
    const saltRounds = 12;
    return bcrypt.hash(password, saltRounds);
  }

  static async verifyPassword(password: string, hash: string): Promise<boolean> {
    return bcrypt.compare(password, hash);
  }

  static generateSecureToken(length: number = 32): string {
    return crypto.randomBytes(length).toString('hex');
  }

  static hashToken(token: string): string {
    return crypto.createHash('sha256').update(token).digest('hex');
  }

  static encrypt(text: string, key: string): string {
    const algorithm = 'aes-256-gcm';
    const iv = crypto.randomBytes(16);
    const cipher = crypto.createCipher(algorithm, key);
    
    let encrypted = cipher.update(text, 'utf8', 'hex');
    encrypted += cipher.final('hex');
    
    const authTag = cipher.getAuthTag();
    
    return iv.toString('hex') + ':' + authTag.toString('hex') + ':' + encrypted;
  }

  static decrypt(encryptedData: string, key: string): string {
    const algorithm = 'aes-256-gcm';
    const parts = encryptedData.split(':');
    
    const iv = Buffer.from(parts[0], 'hex');
    const authTag = Buffer.from(parts[1], 'hex');
    const encrypted = parts[2];
    
    const decipher = crypto.createDecipher(algorithm, key);
    decipher.setAuthTag(authTag);
    
    let decrypted = decipher.update(encrypted, 'hex', 'utf8');
    decrypted += decipher.final('utf8');
    
    return decrypted;
  }
}
```

### 감사 로깅

#### 감사 로그 미들웨어
```typescript
// src/middleware/auditLog.ts
import { AuditLog } from '../models/AuditLog';

export const auditLogger = (action: string, resource: string) => {
  return async (req: Request, res: Response, next: NextFunction) => {
    const originalSend = res.send;
    
    res.send = function(data) {
      // 응답 후 감사 로그 기록
      setImmediate(async () => {
        try {
          await AuditLog.create({
            userId: req.user?.id,
            teamId: req.teamMember?.teamId,
            action,
            resource,
            resourceId: req.params.id,
            metadata: {
              method: req.method,
              url: req.originalUrl,
              statusCode: res.statusCode,
              userAgent: req.get('User-Agent'),
              body: req.body
            },
            ipAddress: req.ip,
            userAgent: req.get('User-Agent')
          });
        } catch (error) {
          Logger.error('Failed to create audit log:', error);
        }
      });
      
      return originalSend.call(this, data);
    };
    
    next();
  };
};
```

### 세션 관리

#### Redis 세션 저장소
```typescript
// src/config/session.ts
import session from 'express-session';
import RedisStore from 'connect-redis';
import { redis } from './redis';

export const sessionConfig = session({
  store: new RedisStore({ client: redis }),
  secret: process.env.SESSION_SECRET!,
  resave: false,
  saveUninitialized: false,
  cookie: {
    secure: process.env.NODE_ENV === 'production',
    httpOnly: true,
    maxAge: 24 * 60 * 60 * 1000, // 24시간
    sameSite: 'strict'
  },
  name: 'teamsync.sid'
});
```

### 보안 체크리스트

#### 배포 전 보안 검증
- [ ] 모든 환경 변수 암호화 저장
- [ ] HTTPS 강제 설정
- [ ] 데이터베이스 연결 암호화
- [ ] API 키 및 시크릿 로테이션
- [ ] 의존성 보안 취약점 스캔
- [ ] 코드 정적 분석 (ESLint Security)
- [ ] 침투 테스트 수행
- [ ] 로그 민감 정보 마스킹
- [ ] 백업 데이터 암호화
- [ ] 접근 로그 모니터링 설정
