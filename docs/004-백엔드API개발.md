# 004-백엔드API개발.md

## Backend API 개발 가이드

### 프로젝트 구조
```
src/backend/
├── src/
│   ├── app.ts              # Express 앱 설정
│   ├── server.ts           # 서버 엔트리 포인트
│   ├── routes/             # API 라우트
│   │   ├── auth.ts
│   │   ├── teams.ts
│   │   ├── configurations.ts
│   │   └── prompts.ts
│   ├── controllers/        # 비즈니스 로직
│   │   ├── authController.ts
│   │   ├── teamController.ts
│   │   └── configController.ts
│   ├── services/           # 서비스 레이어
│   │   ├── authService.ts
│   │   ├── teamService.ts
│   │   └── syncService.ts
│   ├── models/             # 데이터 모델
│   │   ├── User.ts
│   │   ├── Team.ts
│   │   └── Configuration.ts
│   ├── middleware/         # 미들웨어
│   │   ├── auth.ts
│   │   ├── validation.ts
│   │   └── errorHandler.ts
│   ├── utils/              # 유틸리티
│   │   ├── logger.ts
│   │   ├── crypto.ts
│   │   └── validation.ts
│   └── config/             # 설정
│       ├── database.ts
│       └── aws.ts
├── package.json
├── tsconfig.json
└── Dockerfile
```

### 핵심 API 구현

#### 1. Express 앱 설정
```typescript
// src/app.ts
import express from 'express';
import cors from 'cors';
import helmet from 'helmet';
import rateLimit from 'express-rate-limit';
import { authRoutes } from './routes/auth';
import { teamRoutes } from './routes/teams';
import { errorHandler } from './middleware/errorHandler';

const app = express();

// 보안 미들웨어
app.use(helmet());
app.use(cors({
  origin: process.env.FRONTEND_URL,
  credentials: true
}));

// Rate limiting
const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15분
  max: 100 // 요청 제한
});
app.use('/api/', limiter);

// 기본 미들웨어
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true }));

// 라우트 등록
app.use('/api/v1/auth', authRoutes);
app.use('/api/v1/teams', teamRoutes);
app.use('/api/v1/configurations', configRoutes);
app.use('/api/v1/prompts', promptRoutes);

// 에러 핸들링
app.use(errorHandler);

export { app };
```

#### 2. 인증 컨트롤러
```typescript
// src/controllers/authController.ts
export class AuthController {
  async login(req: Request, res: Response, next: NextFunction) {
    try {
      const { provider, code } = req.body;
      
      const userInfo = await authService.exchangeCodeForUser(provider, code);
      const user = await userService.findOrCreateUser(userInfo);
      
      const tokens = await authService.generateTokens(user.id);
      
      res.json({
        user: {
          id: user.id,
          email: user.email,
          name: user.name,
          avatar: user.avatar
        },
        tokens
      });
    } catch (error) {
      next(error);
    }
  }

  async refresh(req: Request, res: Response, next: NextFunction) {
    try {
      const { refreshToken } = req.body;
      
      const tokens = await authService.refreshTokens(refreshToken);
      
      res.json({ tokens });
    } catch (error) {
      next(error);
    }
  }

  async logout(req: Request, res: Response, next: NextFunction) {
    try {
      const { refreshToken } = req.body;
      
      await authService.revokeToken(refreshToken);
      
      res.status(204).send();
    } catch (error) {
      next(error);
    }
  }
}
```

#### 3. 팀 관리 서비스
```typescript
// src/services/teamService.ts
export class TeamService {
  async createTeam(ownerId: string, data: CreateTeamData): Promise<Team> {
    const team = await Team.create({
      ...data,
      ownerId,
      settings: {
        visibility: 'private',
        allowMemberInvite: false,
        requireApproval: true
      }
    });

    // 오너를 팀 멤버로 추가
    await TeamMember.create({
      teamId: team.id,
      userId: ownerId,
      role: 'owner'
    });

    return team;
  }

  async inviteMember(teamId: string, email: string, inviterId: string): Promise<void> {
    // 권한 확인
    const member = await TeamMember.findOne({
      where: { teamId, userId: inviterId }
    });

    if (!member || !['owner', 'admin'].includes(member.role)) {
      throw new Error('권한이 없습니다.');
    }

    // 초대 토큰 생성
    const inviteToken = await this.generateInviteToken(teamId, email);
    
    // 이메일 발송
    await emailService.sendInvitation(email, inviteToken);
  }

  async joinTeam(inviteToken: string, userId: string): Promise<void> {
    const invite = await this.validateInviteToken(inviteToken);
    
    await TeamMember.create({
      teamId: invite.teamId,
      userId,
      role: 'member'
    });

    // 초대 토큰 무효화
    await this.revokeInviteToken(inviteToken);
  }
}
```

#### 4. 설정 동기화 서비스
```typescript
// src/services/syncService.ts
export class SyncService {
  async syncConfiguration(teamId: string, userId: string, configData: ConfigurationData): Promise<Configuration> {
    // 현재 설정 조회
    const currentConfig = await Configuration.findOne({
      where: { teamId },
      order: [['version', 'DESC']]
    });

    // 충돌 감지
    if (currentConfig && this.hasConflicts(currentConfig.settings, configData)) {
      throw new ConflictError('설정 충돌이 감지되었습니다.', {
        current: currentConfig.settings,
        incoming: configData
      });
    }

    // 새 버전 생성
    const newVersion = currentConfig ? currentConfig.version + 1 : 1;
    
    const configuration = await Configuration.create({
      teamId,
      settings: configData,
      version: newVersion,
      createdBy: userId
    });

    // 팀 멤버들에게 알림
    await this.notifyTeamMembers(teamId, 'config:updated', {
      configId: configuration.id,
      version: newVersion
    });

    return configuration;
  }

  private hasConflicts(current: any, incoming: any): boolean {
    // 간단한 충돌 감지 로직
    const currentKeys = Object.keys(current);
    const incomingKeys = Object.keys(incoming);
    
    return currentKeys.some(key => 
      incomingKeys.includes(key) && 
      JSON.stringify(current[key]) !== JSON.stringify(incoming[key])
    );
  }
}
```

### 데이터베이스 모델

#### 1. User 모델
```typescript
// src/models/User.ts
import { DataTypes, Model } from 'sequelize';
import { sequelize } from '../config/database';

export class User extends Model {
  public id!: string;
  public email!: string;
  public name!: string;
  public avatar?: string;
  public provider!: 'google' | 'github' | 'email';
  public providerId?: string;
  public createdAt!: Date;
  public updatedAt!: Date;
  public lastLoginAt?: Date;
}

User.init({
  id: {
    type: DataTypes.UUID,
    defaultValue: DataTypes.UUIDV4,
    primaryKey: true
  },
  email: {
    type: DataTypes.STRING,
    allowNull: false,
    unique: true,
    validate: { isEmail: true }
  },
  name: {
    type: DataTypes.STRING,
    allowNull: false
  },
  avatar: DataTypes.STRING,
  provider: {
    type: DataTypes.ENUM('google', 'github', 'email'),
    allowNull: false
  },
  providerId: DataTypes.STRING,
  lastLoginAt: DataTypes.DATE
}, {
  sequelize,
  modelName: 'User',
  tableName: 'users'
});
```

#### 2. Team 모델
```typescript
// src/models/Team.ts
export class Team extends Model {
  public id!: string;
  public name!: string;
  public description?: string;
  public ownerId!: string;
  public settings!: TeamSettings;
  public createdAt!: Date;
  public updatedAt!: Date;
}

Team.init({
  id: {
    type: DataTypes.UUID,
    defaultValue: DataTypes.UUIDV4,
    primaryKey: true
  },
  name: {
    type: DataTypes.STRING,
    allowNull: false
  },
  description: DataTypes.TEXT,
  ownerId: {
    type: DataTypes.UUID,
    allowNull: false,
    references: { model: User, key: 'id' }
  },
  settings: {
    type: DataTypes.JSONB,
    defaultValue: {}
  }
}, {
  sequelize,
  modelName: 'Team',
  tableName: 'teams'
});
```

### 미들웨어

#### 1. 인증 미들웨어
```typescript
// src/middleware/auth.ts
export const authenticate = async (req: Request, res: Response, next: NextFunction) => {
  try {
    const token = req.headers.authorization?.replace('Bearer ', '');
    
    if (!token) {
      return res.status(401).json({ error: '인증 토큰이 필요합니다.' });
    }

    const payload = jwt.verify(token, process.env.JWT_SECRET!) as JwtPayload;
    const user = await User.findByPk(payload.userId);

    if (!user) {
      return res.status(401).json({ error: '유효하지 않은 토큰입니다.' });
    }

    req.user = user;
    next();
  } catch (error) {
    res.status(401).json({ error: '인증에 실패했습니다.' });
  }
};
```

#### 2. 권한 확인 미들웨어
```typescript
// src/middleware/authorization.ts
export const requireTeamMember = (roles: string[] = []) => {
  return async (req: Request, res: Response, next: NextFunction) => {
    try {
      const { teamId } = req.params;
      const userId = req.user!.id;

      const member = await TeamMember.findOne({
        where: { teamId, userId }
      });

      if (!member) {
        return res.status(403).json({ error: '팀 멤버가 아닙니다.' });
      }

      if (roles.length > 0 && !roles.includes(member.role)) {
        return res.status(403).json({ error: '권한이 부족합니다.' });
      }

      req.teamMember = member;
      next();
    } catch (error) {
      next(error);
    }
  };
};
```

### TODO 리스트

#### Phase 1: 기본 설정 (완료 예정: 2시간)
- [ ] Express + TypeScript 프로젝트 설정
- [ ] 데이터베이스 연결 (PostgreSQL)
- [ ] 기본 미들웨어 설정
- [ ] 환경 변수 관리

#### Phase 2: 인증 시스템 (완료 예정: 4시간)
- [ ] OAuth 2.0 연동 (Google, GitHub)
- [ ] JWT 토큰 생성/검증
- [ ] 토큰 갱신 로직
- [ ] 사용자 모델 및 서비스

#### Phase 3: 팀 관리 API (완료 예정: 3시간)
- [ ] 팀 CRUD API
- [ ] 멤버 초대 시스템
- [ ] 권한 관리
- [ ] 팀 설정 관리

#### Phase 4: 설정 동기화 API (완료 예정: 4시간)
- [ ] 설정 업로드/다운로드
- [ ] 버전 관리
- [ ] 충돌 감지 및 해결
- [ ] 히스토리 관리

#### Phase 5: 실시간 알림 (완료 예정: 3시간)
- [ ] WebSocket 서버 설정
- [ ] 실시간 이벤트 발송
- [ ] 알림 큐 시스템
- [ ] 이메일 알림 서비스
